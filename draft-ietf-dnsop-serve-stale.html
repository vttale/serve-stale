<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Serving Stale Data to Improve DNS Resiliency</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Terminology">
<link href="#rfc.section.3" rel="Chapter" title="3 Background">
<link href="#rfc.section.4" rel="Chapter" title="4 Standards Action">
<link href="#rfc.section.5" rel="Chapter" title="5 Example Method">
<link href="#rfc.section.6" rel="Chapter" title="6 Implementation Considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 Implementation Caveats">
<link href="#rfc.section.8" rel="Chapter" title="8 Implementation Status">
<link href="#rfc.section.9" rel="Chapter" title="9 EDNS Option">
<link href="#rfc.section.10" rel="Chapter" title="10 Security Considerations">
<link href="#rfc.section.11" rel="Chapter" title="11 Privacy Considerations">
<link href="#rfc.section.12" rel="Chapter" title="12 NAT Considerations">
<link href="#rfc.section.13" rel="Chapter" title="13 IANA Considerations">
<link href="#rfc.section.14" rel="Chapter" title="14 Acknowledgements">
<link href="#rfc.references" rel="Chapter" title="15 References">
<link href="#rfc.references.1" rel="Chapter" title="15.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="15.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.6.0 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Lawrence, D., Kumari, W., and P. Sood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-dnsop-serve-stale-10" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-12-09" />
  <meta name="dct.abstract" content="This draft defines a method (serve-stale) for recursive resolvers to use stale DNS data to avoid outages when authoritative nameservers cannot be reached to refresh expired data. One of the motivations for serve-stale is to make the DNS more resilient to DoS attacks, and thereby make them less attractive as an attack vector.  This document updates the definitions of TTL from RFC 1034 and RFC 1035 so that data can be kept in the cache beyond the TTL expiry, updates RFC 2181 by interpreting values with the high order bit set as being positive, rather than 0, and suggests a cap of 7 days." />
  <meta name="description" content="This draft defines a method (serve-stale) for recursive resolvers to use stale DNS data to avoid outages when authoritative nameservers cannot be reached to refresh expired data. One of the motivations for serve-stale is to make the DNS more resilient to DoS attacks, and thereby make them less attractive as an attack vector.  This document updates the definitions of TTL from RFC 1034 and RFC 1035 so that data can be kept in the cache beyond the TTL expiry, updates RFC 2181 by interpreting values with the high order bit set as being positive, rather than 0, and suggests a cap of 7 days." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">DNSOP Working Group</td>
<td class="right">D. Lawrence</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Oracle</td>
</tr>
<tr>
<td class="left">Updates: 1034, 1035, 2181 (if approved)</td>
<td class="right">W. Kumari</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">P. Sood</td>
</tr>
<tr>
<td class="left">Expires: June 11, 2020</td>
<td class="right">Google</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">December 09, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Serving Stale Data to Improve DNS Resiliency<br />
  <span class="filename">draft-ietf-dnsop-serve-stale-10</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This draft defines a method (serve-stale) for recursive resolvers to use stale DNS data to avoid outages when authoritative nameservers cannot be reached to refresh expired data. One of the motivations for serve-stale is to make the DNS more resilient to DoS attacks, and thereby make them less attractive as an attack vector.  This document updates the definitions of TTL from RFC 1034 and RFC 1035 so that data can be kept in the cache beyond the TTL expiry, updates RFC 2181 by interpreting values with the high order bit set as being positive, rather than 0, and suggests a cap of 7 days.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on June 11, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Terminology</a>
</li>
<li>3.   <a href="#rfc.section.3">Background</a>
</li>
<li>4.   <a href="#rfc.section.4">Standards Action</a>
</li>
<li>5.   <a href="#rfc.section.5">Example Method</a>
</li>
<li>6.   <a href="#rfc.section.6">Implementation Considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">Implementation Caveats</a>
</li>
<li>8.   <a href="#rfc.section.8">Implementation Status</a>
</li>
<li>9.   <a href="#rfc.section.9">EDNS Option</a>
</li>
<li>10.   <a href="#rfc.section.10">Security Considerations</a>
</li>
<li>11.   <a href="#rfc.section.11">Privacy Considerations</a>
</li>
<li>12.   <a href="#rfc.section.12">NAT Considerations</a>
</li>
<li>13.   <a href="#rfc.section.13">IANA Considerations</a>
</li>
<li>14.   <a href="#rfc.section.14">Acknowledgements</a>
</li>
<li>15.   <a href="#rfc.references">References</a>
</li>
<ul><li>15.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>15.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">Traditionally the Time To Live (TTL) of a DNS resource record has been understood to represent the maximum number of seconds that a record can be used before it must be discarded, based on its description and usage in <a href="#RFC1035" class="xref">[RFC1035]</a> and clarifications in <a href="#RFC2181" class="xref">[RFC2181]</a>.</p>
<p id="rfc.section.1.p.2">This document expands the definition of the TTL to explicitly allow for expired data to be used in the exceptional circumstance that a recursive resolver is unable to refresh the information.  It is predicated on the observation that authoritative answer unavailability can cause outages even when the underlying data those servers would return is typically unchanged.</p>
<p id="rfc.section.1.p.3">We describe a method below for this use of stale data, balancing the competing needs of resiliency and freshness.</p>
<p id="rfc.section.1.p.4">This document updates the definitions of TTL from <a href="#RFC1034" class="xref">[RFC1034]</a> and <a href="#RFC1035" class="xref">[RFC1035]</a> so that data can be kept in the cache beyond the TTL expiry, and also updates <a href="#RFC2181" class="xref">[RFC2181]</a> by interpreting values with the high order bit set as being positive, rather than 0, and also suggests a cap of 7 days.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.2.p.1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<p id="rfc.section.2.p.2">For a glossary of DNS terms, please see <a href="#RFC8499" class="xref">[RFC8499]</a>.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#background" id="background">Background</a>
</h1>
<p id="rfc.section.3.p.1">There are a number of reasons why an authoritative server may become unreachable, including Denial of Service (DoS) attacks, network issues, and so on.  If a recursive server is unable to contact the authoritative servers for a query but still has relevant data that has aged past its TTL, that information can still be useful for generating an answer under the metaphorical assumption that "stale bread is better than no bread."</p>
<p><a href="#RFC1035" class="xref">[RFC1035]</a> Section 3.2.1 says that the TTL "specifies the time interval that the resource record may be cached before the source of the information should again be consulted", and Section 4.1.3 further says the TTL, "specifies the time interval (in seconds) that the resource record may be cached before it should be discarded."</p>
<p id="rfc.section.3.p.3">A natural English interpretation of these remarks would seem to be clear enough that records past their TTL expiration must not be used.  However, <a href="#RFC1035" class="xref">[RFC1035]</a> predates the more rigorous terminology of <a href="#RFC2119" class="xref">[RFC2119]</a> which softened the interpretation of "may" and "should".</p>
<p><a href="#RFC2181" class="xref">[RFC2181]</a> aimed to provide "the precise definition of the Time to Live", but in Section 8 was mostly concerned with the numeric range of values rather than data expiration behavior.  It does, however, close that section by noting, "The TTL specifies a maximum time to live, not a mandatory time to live."  This wording again does not contain BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> key words, but does convey the natural language connotation that data becomes unusable past TTL expiry.</p>
<p id="rfc.section.3.p.5">As of the time of this writing, several large-scale operators use stale data for answers in some way. A number of recursive resolver packages, including BIND, Knot Resolver, OpenDNS, and Unbound, provide options to use stale data.  Apple MacOS can also use stale data as part of the Happy Eyeballs algorithms in mDNSResponder.  The collective operational experience is that using stale data can provide significant benefit with minimal downside.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#standards-action" id="standards-action">Standards Action</a>
</h1>
<p id="rfc.section.4.p.1">The definition of TTL in <a href="#RFC1035" class="xref">[RFC1035]</a> Sections 3.2.1 and 4.1.3 is amended to read:</p>
<p></p>

<dl>
<dt>TTL</dt>
<dd style="margin-left: 8">a 32-bit unsigned integer number of seconds that specifies the duration that the resource record MAY be cached before the source of the information MUST again be consulted.  Zero values are interpreted to mean that the RR can only be used for the transaction in progress, and should not be cached.  Values SHOULD be capped on the orders of days to weeks, with a recommended cap of 604,800 seconds (seven days). If the data is unable to be authoritatively refreshed when the TTL expires, the record MAY be used as though it is unexpired. See [RFC Editor: replace by RFC number] <a href="#example-method" class="xref">Section 5</a> and <a href="#implementation-considerations" class="xref">Section 6</a> for details.</dd>
</dl>
<p id="rfc.section.4.p.3">Interpreting values which have the high-order bit set as being positive, rather than 0, is a change from <a href="#RFC2181" class="xref">[RFC2181]</a>, the rationale for which is explained in <a href="#implementation-considerations" class="xref">Section 6</a>.  Suggesting a cap of seven days, rather than the 68 years allowed by <a href="#RFC2181" class="xref">[RFC2181]</a>, reflects the current practice of major modern DNS resolvers.</p>
<p id="rfc.section.4.p.4">When returning a response containing stale records, a recursive resolver MUST set the TTL of each expired record in the message to a value greater than 0, with a RECOMMENDED value of 30 seconds. See <a href="#implementation-considerations" class="xref">Section 6</a> for explanation.</p>
<p id="rfc.section.4.p.5">Answers from authoritative servers that have a DNS Response Code of either 0 (NoError) or 3 (NXDomain) and the Authoritative Answers (AA) bit set MUST be considered to have refreshed the data at the resolver.  Answers from authoritative servers that have any other response code SHOULD be considered a failure to refresh the data and therefore leave any previous state intact. See <a href="#implementation-considerations" class="xref">Section 6</a> for a discussion.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#example-method" id="example-method">Example Method</a>
</h1>
<p id="rfc.section.5.p.1">There is more than one way a recursive resolver could responsibly implement this resiliency feature while still respecting the intent of the TTL as a signal for when data is to be refreshed.</p>
<p id="rfc.section.5.p.2">In this example method four notable timers drive considerations for the use of stale data:</p>
<p></p>

<ul>
<li>A client response timer, which is the maximum amount of time a recursive resolver should allow between the receipt of a resolution request and sending its response.</li>
<li>A query resolution timer, which caps the total amount of time a recursive resolver spends processing the query.</li>
<li>A failure recheck timer, which limits the frequency at which a failed lookup will be attempted again.</li>
<li>A maximum stale timer, which caps the amount of time that records will be kept past their expiration.</li>
</ul>
<p id="rfc.section.5.p.4">Most recursive resolvers already have the query resolution timer, and effectively some kind of failure recheck timer.  The client response timer and maximum stale timer are new concepts for this mechanism.</p>
<p id="rfc.section.5.p.5">When a recursive resolver receives a request, it should start the client response timer.  This timer is used to avoid client timeouts.  It should be configurable, with a recommended value of 1.8 seconds as being just under a common timeout value of 2 seconds while still giving the resolver a fair shot at resolving the name.</p>
<p id="rfc.section.5.p.6">The resolver then checks its cache for any unexpired records that satisfy the request and returns them if available.  If it finds no relevant unexpired data and the Recursion Desired flag is not set in the request, it should immediately return the response without consulting the cache for expired records.  Typically this response would be a referral to authoritative nameservers covering the zone, but the specifics are implementation-dependent.</p>
<p id="rfc.section.5.p.7">If iterative lookups will be done, then the failure recheck timer is consulted.  Attempts to refresh from non-responsive or otherwise failing authoritative nameservers are recommended to be done no more frequently than every 30 seconds.  If this request was received within this period, the cache may be immediately consulted for stale data to satisfy the request.</p>
<p id="rfc.section.5.p.8">Outside the period of the failure recheck timer, the resolver should start the query resolution timer and begin the iterative resolution process.  This timer bounds the work done by the resolver when contacting external authorities, and is commonly around 10 to 30 seconds.  If this timer expires on an attempted lookup that is still being processed, the resolution effort is abandoned.</p>
<p id="rfc.section.5.p.9">If the answer has not been completely determined by the time the client response timer has elapsed, the resolver should then check its cache to see whether there is expired data that would satisfy the request.  If so, it adds that data to the response message with a TTL greater than 0 (as specified in <a href="#standards-action" class="xref">Section 4</a>).  The response is then sent to the client while the resolver continues its attempt to refresh the data.</p>
<p id="rfc.section.5.p.10">When no authorities are able to be reached during a resolution attempt, the resolver should attempt to refresh the delegation and restart the iterative lookup process with the remaining time on the query resolution timer. This resumption should be done only once per resolution effort.</p>
<p id="rfc.section.5.p.11">Outside the resolution process, the maximum stale timer is used for cache management and is independent of the query resolution process. This timer is conceptually different from the maximum cache TTL that exists in many resolvers, the latter being a clamp on the value of TTLs as received from authoritative servers and recommended to be seven days in the TTL definition in <a href="#standards-action" class="xref">Section 4</a>.  The maximum stale timer should be configurable, and defines the length of time after a record expires that it should be retained in the cache.  The suggested value is between 1 and 3 days.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#implementation-considerations" id="implementation-considerations">Implementation Considerations</a>
</h1>
<p id="rfc.section.6.p.1">This document mainly describes the issues behind serving stale data and intentionally does not provide a formal algorithm. The concept is not overly complex, and the details are best left to resolver authors to implement in their codebases. The processing of serve-stale is a local operation, and consistent variables between deployments are not needed for interoperability.  However, we would like to highlight the impact of various implementation choices, starting with the timers involved.</p>
<p id="rfc.section.6.p.2">The most obvious of these is the maximum stale timer. If this variable is too large it could cause excessive cache memory usage, but if it is too small, the serve-stale technique becomes less effective, as the record may not be in the cache to be used if needed.  Shorter values, even less than a day, can effectively handle the vast majority of outages.  Longer values, as much as a week, give time for monitoring systems to notice a resolution problem and for human intervention to fix it; operational experience has been that sometimes the right people can be hard to track down and unfortunately slow to remedy the situation.</p>
<p id="rfc.section.6.p.3">Increased memory consumption could be mitigated by prioritizing removal of stale records over non-expired records during cache exhaustion.  Implementations may also wish to consider whether to track the names in requests for their last time of use or their popularity, using that as an additional factor when considering cache eviction.  A feature to manually flush only stale records could also be useful.</p>
<p id="rfc.section.6.p.4">The client response timer is another variable which deserves consideration. If this value is too short, there exists the risk that stale answers may be used even when the authoritative server is actually reachable but slow; this may result in undesirable answers being returned. Conversely, waiting too long will negatively impact user experience.</p>
<p id="rfc.section.6.p.5">The balance for the failure recheck timer is responsiveness in detecting the renewed availability of authorities versus the extra resource use for resolution. If this variable is set too large, stale answers may continue to be returned even after the authoritative server is reachable; per <a href="#RFC2308" class="xref">[RFC2308]</a>, Section 7, this should be no more than five minutes.  If this variable is too small, authoritative servers may be targeted with a significant amount of excess traffic.</p>
<p id="rfc.section.6.p.6">Regarding the TTL to set on stale records in the response, historically TTLs of zero seconds have been problematic for some implementations, and negative values can't effectively be communicated to existing software.  Other very short TTLs could lead to congestive collapse as TTL-respecting clients rapidly try to refresh.  The recommended value of 30 seconds not only sidesteps those potential problems with no practical negative consequences, it also rate limits further queries from any client that honors the TTL, such as a forwarding resolver.</p>
<p id="rfc.section.6.p.7">As for the change to treat a TTL with the high-order bit set as positive and then clamping it, as opposed to <a href="#RFC2181" class="xref">[RFC2181]</a> treating it as zero, the rationale here is basically one of engineering simplicity versus an inconsequential operational history.  Negative TTLs had no rational intentional meaning that wouldn't have been satisfied by just sending 0 instead, and similarly there was realistically no practical purpose for sending TTLs of 2^25 seconds (1 year) or more.  There's also no record of TTLs in the wild having the most significant bit set in DNS-OARC's "Day in the Life" samples <a href="#DITL" class="xref">[DITL]</a>.  With no apparent reason for operators to use them intentionally, that leaves either errors or non-standard experiments as explanations as to why such TTLs might be encountered, with neither providing an obviously compelling reason as to why having the leading bit set should be treated differently from having any of the next eleven bits set and then capped per <a href="#standards-action" class="xref">Section 4</a>.</p>
<p id="rfc.section.6.p.8">Another implementation consideration is the use of stale nameserver addresses for lookups.  This is mentioned explicitly because, in some resolvers, getting the addresses for nameservers is a separate path from a normal cache lookup. If authoritative server addresses are not able to be refreshed, resolution can possibly still be successful if the authoritative servers themselves are up.  For instance, consider an attack on a top-level domain that takes its nameservers offline; serve-stale resolvers that had expired glue addresses for subdomains within that TLD would still be able to resolve names within those subdomains, even those it had not previously looked up.</p>
<p id="rfc.section.6.p.9">The directive in <a href="#standards-action" class="xref">Section 4</a> that only NoError and NXDomain responses should invalidate any previously associated answer stems from the fact that no other RCODEs that a resolver normally encounters make any assertions regarding the name in the question or any data associated with it.  This comports with existing resolver behavior where a failed lookup (say, during pre-fetching) doesn't impact the existing cache state.  Some authoritative server operators have said that they would prefer stale answers to be used in the event that their servers are responding with errors like ServFail instead of giving true authoritative answers.  Implementers MAY decide to return stale answers in this situation.</p>
<p id="rfc.section.6.p.10">Since the goal of serve-stale is to provide resiliency for all obvious errors to refresh data, these other RCODEs are treated as though they are equivalent to not getting an authoritative response.  Although NXDomain for a previously existing name might well be an error, it is not handled that way because there is no effective way to distinguish operator intent for legitimate cases versus error cases.</p>
<p id="rfc.section.6.p.11">During discussion in the IETF, it was suggested that, if all authorities return responses with RCODE of Refused, it may be an explicit signal to take down the zone from servers that still have the zone's delegation pointed to them.  Refused, however, is also overloaded to mean multiple possible failures which could represent transient configuration failures.  Operational experience has shown that purposely returning Refused is a poor way to achieve an explicit takedown of a zone compared to either updating the delegation or returning NXDomain with a suitable SOA for extended negative caching.  Implementers MAY nonetheless consider whether to treat all authorities returning Refused as preempting the use of stale data.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#implementation-caveats" id="implementation-caveats">Implementation Caveats</a>
</h1>
<p id="rfc.section.7.p.1">Stale data is used only when refreshing has failed in order to adhere to the original intent of the design of the DNS and the behaviour expected by operators.  If stale data were to always be used immediately and then a cache refresh attempted after the client response has been sent, the resolver would frequently be sending data that it would have had no trouble refreshing.  Because modern resolvers use techniques like pre-fetching and request coalescing for efficiency, it is not necessary that every client request needs to trigger a new lookup flow in the presence of stale data, but rather that a good-faith effort has been recently made to refresh the stale data before it is delivered to any client.</p>
<p id="rfc.section.7.p.2">It is important to continue the resolution attempt after the stale response has been sent, until the query resolution timeout, because some pathological resolutions can take many seconds to succeed as they cope with unavailable servers, bad networks, and other problems.  Stopping the resolution attempt when the response with expired data has been sent would mean that answers in these pathological cases would never be refreshed.</p>
<p id="rfc.section.7.p.3">The continuing prohibition against using data with a 0 second TTL beyond the current transaction explicitly extends to it being unusable even for stale fallback, as it is not to be cached at all.</p>
<p id="rfc.section.7.p.4">Be aware that Canonical Name (CNAME) and DNAME <a href="#RFC6672" class="xref">[RFC6672]</a> records mingled in the expired cache with other records at the same owner name can cause surprising results.  This was observed with an initial implementation in BIND when a hostname changed from having an IPv4 Address (A) record to a CNAME.  The version of BIND being used did not evict other types in the cache when a CNAME was received, which in normal operations is not a significant issue.  However, after both records expired and the authorities became unavailable, the fallback to stale answers returned the older A instead of the newer CNAME.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#implementation-status" id="implementation-status">Implementation Status</a>
</h1>
<p id="rfc.section.8.p.1">The algorithm described in <a href="#example-method" class="xref">Section 5</a> was originally implemented as a patch to BIND 9.7.0.  It has been in use on Akamai's production network since 2011, and effectively smoothed over transient failures and longer outages that would have resulted in major incidents.  The patch was contributed to Internet Systems Consortium and the functionality is now available in BIND 9.12 and later via the options stale-answer-enable, stale-answer-ttl, and max-stale-ttl.</p>
<p id="rfc.section.8.p.2">Unbound has a similar feature for serving stale answers, and will respond with stale data immediately if it has recently tried and failed to refresh the answer by pre-fetching.  Starting from version 1.10.0 unbound can also be configured to follow the algorithm described in Section 5.  Both behaviors can be configured and fine-tuned with the available serve-expired-* options.</p>
<p id="rfc.section.8.p.3">Knot Resolver has a demo module here: https://knot-resolver.readthedocs.io/en/stable/modules.html#serve-stale</p>
<p id="rfc.section.8.p.4">Apple's system resolvers are also known to use stale answers, but the details are not readily available.</p>
<p id="rfc.section.8.p.5">In the research paper "When the Dike Breaks: Dissecting DNS Defenses During DDoS" <a href="#DikeBreaks" class="xref">[DikeBreaks]</a>, the authors detected some use of stale answers by resolvers when authorities came under attack.  Their research results suggest that more widespread adoption of the technique would significantly improve resiliency for the large number of requests that fail or experience abnormally long resolution times during an attack.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#edns-option" id="edns-option">EDNS Option</a>
</h1>
<p id="rfc.section.9.p.1">During the discussion of serve-stale in the IETF, it was suggested that an EDNS option should be available to either explicitly opt-in to getting data that is possibly stale, or at least as a debugging tool to indicate when stale data has been used for a response.</p>
<p id="rfc.section.9.p.2">The opt-in use case was rejected as the technique was meant to be immediately useful in improving DNS resiliency for all clients.</p>
<p id="rfc.section.9.p.3">The reporting case was ultimately also rejected because even the simpler version of a proposed option was still too much bother to implement for too little perceived value.</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.10.p.1">The most obvious security issue is the increased likelihood of DNSSEC validation failures when using stale data because signatures could be returned outside their validity period. Stale negative records can increase the time window where newly published TLSA or DS RRs may not be used due to cached NSEC or NSEC3 records. These scenarios would only be an issue if the authoritative servers are unreachable, the only time the techniques in this document are used, and thus does not introduce a new failure in place of what would have otherwise been success.</p>
<p id="rfc.section.10.p.2">Additionally, bad actors have been known to use DNS caches to keep records alive even after their authorities have gone away. The serve stale feature potentially makes the attack easier, although without introducing a new risk. In addition, attackers could combine this with a DDoS attack on authoritative servers with the explicit intent of having stale information cached for longer. But if attackers have this capacity, they probably could do much worse than prolonging the life of old data.</p>
<p id="rfc.section.10.p.3">In <a href="#CloudStrife" class="xref">[CloudStrife]</a>, it was demonstrated how stale DNS data, namely hostnames pointing to addresses that are no longer in use by the owner of the name, can be used to co-opt security such as to get domain-validated certificates fraudulently issued to an attacker.  While this document does not create a new vulnerability in this area, it does potentially enlarge the window in which such an attack could be made.  A proposed mitigation is that certificate authorities should fully look up each name starting at the DNS root for every name lookup.  Alternatively, CAs should use a resolver that is not serving stale data.</p>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#privacy-considerations" id="privacy-considerations">Privacy Considerations</a>
</h1>
<p id="rfc.section.11.p.1">This document does not add any practical new privacy issues.</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#nat-considerations" id="nat-considerations">NAT Considerations</a>
</h1>
<p id="rfc.section.12.p.1">The method described here is not affected by the use of NAT devices.</p>
<h1 id="rfc.section.13">
<a href="#rfc.section.13">13.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.13.p.1">There are no IANA considerations.</p>
<h1 id="rfc.section.14">
<a href="#rfc.section.14">14.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a>
</h1>
<p id="rfc.section.14.p.1">The authors wish to thank Brian Carpenter, Vladimir Cunat, Robert Edmonds, Tony Finch, Bob Harold, Tatuya Jinmei, Matti Klock, Jason Moreau, Giovane Moura, Jean Roy, Mukund Sivaraman, Davey Song, Paul Vixie, Ralf Weber and Paul Wouters for their review and feedback.  Paul Hoffman deserves special thanks for submitting a number of Pull Requests.</p>
<p id="rfc.section.14.p.2">Thank you also to the following members of the IESG for their final review:  Roman Danyliw, Benjamin Kaduk, Suresh Krishnan, Mirja Kuehlewind, and Adam Roach.</p>
<h1 id="rfc.references">
<a href="#rfc.references">15.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">15.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC1034">[RFC1034]</b></td>
<td class="top">
<a>Mockapetris, P.</a>, "<a href="http://tools.ietf.org/html/rfc1034">Domain names - concepts and facilities</a>", STD 13, RFC 1034, DOI 10.17487/RFC1034, November 1987.</td>
</tr>
<tr>
<td class="reference"><b id="RFC1035">[RFC1035]</b></td>
<td class="top">
<a>Mockapetris, P.</a>, "<a href="http://tools.ietf.org/html/rfc1035">Domain names - implementation and specification</a>", STD 13, RFC 1035, DOI 10.17487/RFC1035, November 1987.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2181">[RFC2181]</b></td>
<td class="top">
<a>Elz, R.</a> and <a>R. Bush</a>, "<a href="http://tools.ietf.org/html/rfc2181">Clarifications to the DNS Specification</a>", RFC 2181, DOI 10.17487/RFC2181, July 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2308">[RFC2308]</b></td>
<td class="top">
<a>Andrews, M.</a>, "<a href="http://tools.ietf.org/html/rfc2308">Negative Caching of DNS Queries (DNS NCACHE)</a>", RFC 2308, DOI 10.17487/RFC2308, March 1998.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="http://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">15.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="CloudStrife">[CloudStrife]</b></td>
<td class="top">
<a>Borgolte, K.</a>, <a>Fiebig, T.</a>, <a>Hao, S.</a>, <a>Kruegel, C.</a> and <a>G. Vigna</a>, "<a href="https://www.ndss-symposium.org/wp-content/uploads/2018/02/ndss2018_06A-4_Borgolte_paper.pdf">Cloud Strife: Mitigating the Security Risks of Domain-Validated Certificates</a>", ACM 2018 Applied Networking Research Workshop, DOI 10.1145/3232755.3232859, July 2018.</td>
</tr>
<tr>
<td class="reference"><b id="DikeBreaks">[DikeBreaks]</b></td>
<td class="top">
<a>Moura, G.</a>, <a>Heidemann, J.</a>, <a>Mueller, M.</a>, <a>Schmidt, R.</a> and <a>M. Davids</a>, "<a href="https://www.isi.edu/~johnh/PAPERS/Moura18b.pdf">When the Dike Breaks: Dissecting DNS Defenses During DDos</a>", ACM 2018 Internet Measurement Conference, DOI 10.1145/3278532.3278534, October 2018.</td>
</tr>
<tr>
<td class="reference"><b id="DITL">[DITL]</b></td>
<td class="top">"<a href="https://www.dns-oarc.net/oarc/data/ditl">DITL Traces and Analysis | DNS-OARC</a>", n.d..</td>
</tr>
<tr>
<td class="reference"><b id="RFC6672">[RFC6672]</b></td>
<td class="top">
<a>Rose, S.</a> and <a>W. Wijngaards</a>, "<a href="http://tools.ietf.org/html/rfc6672">DNAME Redirection in the DNS</a>", RFC 6672, DOI 10.17487/RFC6672, June 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8499">[RFC8499]</b></td>
<td class="top">
<a>Hoffman, P.</a>, <a>Sullivan, A.</a> and <a>K. Fujiwara</a>, "<a href="http://tools.ietf.org/html/rfc8499">DNS Terminology</a>", BCP 219, RFC 8499, DOI 10.17487/RFC8499, January 2019.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">David C Lawrence</span> 
	  <span class="n hidden">
		<span class="family-name">Lawrence</span>
	  </span>
	</span>
	<span class="org vcardline">Oracle</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:tale@dd.org">tale@dd.org</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Warren "Ace" Kumari</span> 
	  <span class="n hidden">
		<span class="family-name">Kumari</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  <span class="vcardline">1600 Amphitheatre Parkway</span>

	  <span class="vcardline">
		<span class="locality">Mountain View</span>,  
		<span class="region"></span>
		<span class="code">CA 94043</span>
	  </span>
	  <span class="country-name vcardline">USA</span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:warren@kumari.net">warren@kumari.net</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Puneet Sood</span> 
	  <span class="n hidden">
		<span class="family-name">Sood</span>
	  </span>
	</span>
	<span class="org vcardline">Google</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:puneets@google.com">puneets@google.com</a></span>

  </address>
</div>

</body>
</html>
